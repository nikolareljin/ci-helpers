name: Gitleaks Scan
description: Run Gitleaks scan and emit a report.
inputs:
  scan_path:
    description: Path to scan (relative to repo root).
    default: "."
    required: false
  report_format:
    description: Report format (sarif only; gitleaks-action output).
    default: sarif
    required: false
  output:
    description: Output report file path.
    default: results.sarif
    required: false
  config_path:
    description: Optional Gitleaks config file path.
    default: ""
    required: false
  fail_on_findings:
    description: Fail when findings are detected.
    default: "false"
    required: false
  upload_artifact:
    description: Upload the report as an artifact.
    default: "false"
    required: false
  artifact_name:
    description: Artifact name when uploading the report.
    default: gitleaks-report
    required: false
runs:
  using: composite
  steps:
    - name: Prepare report path
      shell: bash
      run: |
        set -euo pipefail
        output="${{ inputs.output }}"
        mkdir -p "$(dirname "$output")"
    - name: Gitleaks scan
      uses: gitleaks/gitleaks-action@v2
      env:
        GITHUB_TOKEN: ${{ github.token }}
    - name: Normalize report output
      shell: bash
      run: |
        set -euo pipefail
        requested_output="${{ inputs.output }}"
        default_output="results.sarif"

        if [[ "${{ inputs.scan_path }}" != "." ]]; then
          echo "Warning: gitleaks-action ignores scan_path; it scans git history by default." >&2
        fi
        if [[ -n "${{ inputs.config_path }}" ]]; then
          echo "Warning: gitleaks-action ignores config_path; only .gitleaks.toml is auto-detected." >&2
        fi
        if [[ "${{ inputs.report_format }}" != "sarif" ]]; then
          echo "Warning: gitleaks-action emits SARIF only; overriding report_format to sarif." >&2
        fi

        if [[ -f "$default_output" && "$requested_output" != "$default_output" ]]; then
          mkdir -p "$(dirname "$requested_output")"
          cp "$default_output" "$requested_output"
        fi
    - name: Evaluate findings
      shell: bash
      run: |
        set -euo pipefail
        report_format="${{ inputs.report_format }}"
        output="${{ inputs.output }}"
        fail_on_findings="${{ inputs.fail_on_findings }}"

        if [[ "$report_format" != "sarif" ]]; then
          report_format="sarif"
        fi
        if [[ ! -f "$output" && -f "results.sarif" ]]; then
          output="results.sarif"
        fi

        REPORT_FORMAT="$report_format" OUTPUT="$output" FAIL_ON_FINDINGS="$fail_on_findings" python3 - <<'PY'
        import json
        import os
        import sys

        report_format = os.environ["REPORT_FORMAT"]
        output = os.environ["OUTPUT"]
        fail_on_findings = os.environ["FAIL_ON_FINDINGS"] == "true"

        count = 0
        if report_format == "sarif":
            with open(output, "r", encoding="utf-8") as fh:
                data = json.load(fh)
            runs = data.get("runs", [])
            for run in runs:
                results = run.get("results", [])
                if isinstance(results, list):
                    count += len(results)
        else:
            with open(output, "r", encoding="utf-8") as fh:
                data = json.load(fh)
            if isinstance(data, list):
                count = len(data)
            elif isinstance(data, dict):
                for key in ("findings", "leaks", "results", "issues"):
                    value = data.get(key)
                    if isinstance(value, list):
                        count += len(value)

        if count > 0:
            print(f"Gitleaks findings detected: {count}")
            print("Tip: remove leaked secrets with Leak-Lock:")
            print("  https://marketplace.visualstudio.com/items?itemName=NikolaReljin.leak-lock")
            print("  https://open-vsx.org/extension/nikolareljin/leak-lock")
            if fail_on_findings:
                sys.exit(3)
        else:
            print("No Gitleaks findings detected.")
        PY
    - name: Upload artifact
      if: ${{ inputs.upload_artifact == 'true' && always() }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.artifact_name }}
        path: ${{ inputs.output }}
        if-no-files-found: warn
