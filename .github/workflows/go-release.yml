name: go-release
on:
  workflow_call:
    inputs:
      runner:
        type: string
        default: ubuntu-latest
      working_directory:
        type: string
        default: "."
      fetch_depth:
        type: number
        default: 0
      go_version:
        type: string
        default: "1.22"
      bin_name:
        type: string
        required: true
      main_path:
        type: string
        default: "."
      artifact_dir:
        type: string
        default: "artifacts"
      build_targets:
        type: string
        default: "linux/amd64,windows/amd64,darwin/amd64"
      ldflags:
        type: string
        default: ""
      release_tag:
        type: string
        default: ""
      binary_links:
        type: string
        default: ""
      binary_base_url:
        type: string
        default: ""
      release_name:
        type: string
        default: ""
      release_notes:
        type: string
        default: ""
      generate_release_notes:
        type: boolean
        default: true

jobs:
  release:
    runs-on: ${{ inputs.runner }}
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: ${{ inputs.fetch_depth }}
          fetch-tags: true

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ inputs.go_version }}

      - name: Build release binaries
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          set -euo pipefail
          mkdir -p "${{ inputs.artifact_dir }}"
          ldflags="${{ inputs.ldflags }}"
          IFS=',' read -r -a targets <<< "${{ inputs.build_targets }}"

          for target in "${targets[@]}"; do
            goos="${target%%/*}"
            goarch="${target##*/}"
            if [ -z "$goos" ] || [ -z "$goarch" ] || [ "$goos" = "$goarch" ]; then
              echo "Invalid target: $target (expected os/arch)" >&2
              exit 2
            fi

            suffix="${goos}-${goarch}"
            ext=""
            if [ "$goos" = "windows" ]; then
              ext=".exe"
            fi

            out="${{ inputs.artifact_dir }}/${{ inputs.bin_name }}-${suffix}${ext}"
            if [ -n "$ldflags" ]; then
              env CGO_ENABLED=0 GOOS="$goos" GOARCH="$goarch" \
                go build -o "$out" -ldflags "$ldflags" "${{ inputs.main_path }}"
            else
              env CGO_ENABLED=0 GOOS="$goos" GOARCH="$goarch" \
                go build -o "$out" "${{ inputs.main_path }}"
            fi
          done

          ls -al "${{ inputs.artifact_dir }}"

      - name: Collect binary links
        id: binaries
        shell: bash
        run: |
          set -euo pipefail
          binary_links="${{ inputs.binary_links }}"
          if [ -n "$binary_links" ]; then
            echo "links<<EOF" >> "$GITHUB_OUTPUT"
            echo "$binary_links" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          links=()
          bin="${{ inputs.bin_name }}"
          IFS=',' read -r -a targets <<< "${{ inputs.build_targets }}"
          for target in "${targets[@]}"; do
            goos="${target%%/*}"
            goarch="${target##*/}"
            suffix="${goos}-${goarch}"
            filename="${bin}-${suffix}"
            if [ "$goos" = "windows" ]; then
              filename="${filename}.exe"
            fi
            label="${goos} ${goarch}"
            links+=("${label}|${filename}")
          done

          echo "links<<EOF" >> "$GITHUB_OUTPUT"
          printf "%s\n" "${links[@]}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Generate release notes
        id: notes
        if: ${{ inputs.generate_release_notes }}
        shell: bash
        run: |
          set -euo pipefail
          repo_dir="${GITHUB_WORKSPACE:-.}"
          cd "$repo_dir"

          since_tag=""
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            since_tag="$(git describe --tags --abbrev=0)"
          fi

          notes_file="$(mktemp)"
          if [ -n "$since_tag" ]; then
            git log --pretty=format:"* %s" "${since_tag}..HEAD" > "$notes_file"
          else
            git log --pretty=format:"* %s" > "$notes_file"
          fi

          if [ ! -s "$notes_file" ]; then
            echo "* No changes listed." > "$notes_file"
          fi

          release_tag="${{ inputs.release_tag }}"
          if [ -z "$release_tag" ]; then
            release_tag="${GITHUB_REF_NAME:-}"
          fi

          binary_base_url="${{ inputs.binary_base_url }}"
          if [ -z "$binary_base_url" ] && [ -n "$release_tag" ]; then
            binary_base_url="https://github.com/${GITHUB_REPOSITORY}/releases/download/${release_tag}"
          fi

          binary_links="${{ steps.binaries.outputs.links }}"
          if [ -n "$binary_links" ] && [ -n "$binary_base_url" ]; then
            {
              echo ""
              echo "## Download Binaries"
              echo ""
              echo "| Platform | Binary |"
              echo "|----------|--------|"
            } >> "$notes_file"

            while IFS= read -r line; do
              trimmed="${line#"${line%%[![:space:]]*}"}"
              if [ -z "$trimmed" ]; then
                continue
              fi
              label="${trimmed%%|*}"
              filename="${trimmed#*|}"
              if [ -z "$label" ] || [ -z "$filename" ] || [ "$label" = "$filename" ]; then
                continue
              fi
              printf "| %s | [%s](%s/%s) |\n" "$label" "$filename" "$binary_base_url" "$filename" >> "$notes_file"
            done <<< "$binary_links"
          fi

          notes_content="$(cat "$notes_file")"
          echo "notes<<EOF" >> "$GITHUB_OUTPUT"
          echo "$notes_content" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ inputs.release_tag != '' && inputs.release_tag || github.ref }}
          release_name: ${{ inputs.release_name != '' && inputs.release_name || format('Release {0}', github.ref_name) }}
          body: ${{ inputs.release_notes != '' && inputs.release_notes || steps.notes.outputs.notes }}
          files: ${{ inputs.working_directory }}/${{ inputs.artifact_dir }}/*
          update_existing: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
